#!/usr/bin/env ruby
require 'gli'
begin # XXX: Remove this begin/rescue before distributing your app
require 'wmonk'
rescue LoadError
  STDERR.puts "In development, you need to use `bundle exec bin/todo` to run your app"
  STDERR.puts "At install-time, RubyGems will make sure lib, etc. are in the load path"
  STDERR.puts "Feel free to remove this message from bin/todo now"
  exit 64
end

include GLI::App

program_desc 'Make a static copy of a website'

version Wmonk::VERSION

desc 'Be verbose'
switch [:v,:verbose]

desc 'Specify working folder'
arg_name 'folder', :optional
default_value "."
flag [:p,:pathname]

desc 'Initialize a folder to copy a website'
long_desc <<EOS
Create folder if it does not exist.  Populate folder with initial configuration files.
EOS

arg_name 'seed URL(s)'
command :init do |c|
  c.desc 'Augment seeds with well known files'
  c.switch [:a, :augment]

  c.action do |global,options,args|

    # determine seed URLs
    if args.length == 0
      raise "no seed URLs supplied"
    end
    url = []
    args.each do |u|
      if u =~ URI::DEFAULT_PARSER.regexp[:ABS_URI]
        url.push u
        puts "Seed URL: #{u}" if global[:verbose]
      else
        raise "bad seed URL: #{u}"
      end
    end

    # determine protocols/hostnames/ports to limit spidering
    base_url = {}
    url.each do |u|
      u = URI.parse u
      u.scheme = u.scheme.downcase
      raise "#{u.scheme} scheme not supported: #{u}" if ! ['http', 'https'].include? u.scheme
      u.host = u.host.downcase
      base_url[u.host] = {} if ! base_url.has_key? u.host
      base_url[u.host][u.port] = {} if ! base_url[u.host].has_key? u.port
      base_url[u.host][u.port][u.scheme] = nil
    end

    # create working folder if it does not exist
    if ! File.exists? global[:pathname]
      puts "Creating working folder: #{global[:pathname]}" if global[:verbose]
      begin
        Dir.mkdir global[:pathname]
      rescue e
        raise e.message
      end
    end

    # error if working folder is not empty
    if ! (Dir.entries(global[:pathname]) - %w{ . .. }).empty?
      raise "cannot initialize non-empty working folder - #{global[:pathname]}"
    end

    conf_filename = Pathname.new(global[:pathname]) + 'spider.yaml'
    puts "Creating configuration file: #{conf_filename}" if global[:verbose]

    # augment seed URLs
    if options[:augment]
      puts "Augmenting seed URLs with well known files" if global[:verbose]
      YAML::load(File.open(File.join(File.dirname(__FILE__), '../assets/well_known_files.yaml')), 'r').each do |path|
        base_url.each do |host, ports|
          ports.each do |port, schemes|
            schemes.each_key do |scheme|
              url.push URI.parse("#{scheme}://#{host}:#{port}#{path}").to_s
            end
          end
        end
      end
    end

    # read spider.yaml template and substitute values
    SEED_URLS = {'seed_urls' => url}
    conf = ERB.new(File.open(File.join(File.dirname(__FILE__), '../assets/spider.yaml.template'), 'r').read).result

    puts "Writing spider.yaml" if global[:verbose]
    begin
      File.open(Pathname.new(global[:pathname]) + 'spider.yaml', 'w') { |f| f.write(conf) }
    rescue e
      raise e.message
    end
  end
end

pre do |global,command,options,args|
  # Pre logic here
  # Return true to proceed; false to abourt and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only
  puts "Requested pathname for working folder: #{global[:pathname]}" if global[:verbose]
  if File.exists? global[:pathname]
    puts "Pathname exists" if global[:verbose]
    if File.directory? global[:pathname]
      puts "Pathname is a folder" if global[:verbose]
    else
      raise "pathname for working folder is not a folder - #{global[:pathname]}"
    end
  else
    puts "Pathname does not exist" if global[:verbose]
  end
  true
end

post do |global,command,options,args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |exception|
  # Error logic here
  # return false to skip default error handling
  true
end

exit run(ARGV)
