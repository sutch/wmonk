#!/usr/bin/env ruby
require 'gli'
require 'wmonk'

include GLI::App

program_desc 'Make a static copy of a website'

version Wmonk::VERSION

desc 'Be verbose'
switch [:v,:verbose]

desc 'Specify working folder'
arg_name 'folder', :optional
default_value "."
flag [:p,:pathname]

desc 'Initialize a folder to copy a website'
long_desc <<EOS
Create folder if it does not exist.  Populate folder with project configuration file.
EOS

arg_name 'seed URL(s)'
command :init do |c|
  c.desc 'Augment seed URLs with well known files'
  c.switch [:a, :augment]

  c.action do |global,options,args|
    raise "no seed URLs supplied" if args.length == 0
    Wmonk::Project.create(global[:pathname], seed_urls: args, seed_well_known_files: options[:augment])
  end
end

desc 'Spider the website'
long_desc <<EOS
Spider the website and create a local copy of the website responses.
EOS

# TODO: gracefully handle Ctrl-C (close SQLite3 database)
# TODO: if SQLite3 database exists, re-get URLs as initial URLs

command :spider do |c|
  c.action do |global,options,args|
    project = Wmonk::Project.open(global[:pathname])

    #urls = conf['seed_urls']
    #
    ## determine host, port and scheme; ensure configuration is limited to one website
    #host = port = scheme = nil
    #urls.each do |u|
    #  u = URI.parse u
    #  u.scheme = u.scheme.downcase
    #  raise "#{u.scheme} scheme not supported: #{u}" if ! ['http', 'https'].include? u.scheme
    #  u.host = u.host.downcase
    #  if host == nil
    #    host = u.host
    #    port = u.port
    #    scheme = u.scheme
    #  end
    #  if host != u.host or port != u.port or scheme != u.scheme
    #    url_1 = URI.parse("#{scheme}://#{host}:#{port}").to_s
    #    url_2 = URI.parse("#{u.scheme}://#{u.host}:#{u.port}").to_s
    #    raise "multiple websites not supported: requested #{url_1} and #{url_2}"
    #  end
    #end
    #u = URI.parse("#{scheme}://#{host}:#{port}")
    #puts "Configured to spider #{u.to_s}" if global[:verbose]
    #
    #copy_exists = File.exist?(Pathname.new(global[:pathname]) + 'spider.sqlite')
    storage = Wmonk::AnemoneStorageSQLite3.new((Pathname.new(global[:pathname]) + 'spider.sqlite').to_s)
    #urls = storage.not_visited_urls if copy_exists

    Anemone.crawl(project.seed_urls, verbose: true, page_class: Anemone::Resource) do |anemone|
      anemone.storage = storage

      anemone.on_every_page do |page|
        puts "on_every_page: #{page.url} (#{page.code}) #{page.content_type} length: #{page.body.length} => processing (on_every_page)" #if global[:verbose]
      end

      anemone.focus_crawl { |page|
        puts "focus_crawl: #{page.url} => processing (focus_crawl)" if global[:verbose]
        #page.links
        links = page.links
        puts "focus_crawl: number of links = #{links.count}"
        links
      }
    end
  end
end

desc 'Serve website from static copy'
long_desc <<EOS
View static copy of website from a web browser.
EOS

command :serve_web do |c|
  c.desc 'Port from which to serve website'
  c.switch [:p, :port]

  c.action do |global,options,args|
    copy = Wmonk::Copy.new(global[:pathname])
    Wmonk::WebServer.new(copy, port: options[:port]).start
  end
end

command :serve_info do |c|
  c.desc 'Port from which to serve information about website'
  c.switch [:p, :port]

  c.action do |global,options,args|
    copy = Wmonk::Copy.new(global[:pathname])
    Wmonk::InfoServer.new(copy, type: :info).start
  end
end

pre do |global,command,options,args|
  # Pre logic here
  # Return true to proceed; false to abort and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only
  puts "Requested pathname for working folder: #{global[:pathname]}" if global[:verbose]
  if File.exists? global[:pathname]
    puts "Pathname exists" if global[:verbose]
    if File.directory? global[:pathname]
      puts "Pathname is a folder" if global[:verbose]
    else
      raise "pathname for working folder is not a folder - #{global[:pathname]}"
    end
  else
    puts "Pathname does not exist" if global[:verbose]
  end
  true
end

post do |global,command,options,args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |exception|
  # Error logic here
  # return false to skip default error handling
  true
end

exit run(ARGV)
